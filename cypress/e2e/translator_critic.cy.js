// ===========================================================================================
// translator_critic.cy.js - UI тесты для приложения "AI Translator & Critic"
// ===========================================================================================
// Этот файл содержит Cypress тесты для проверки:
// 1. Успешного перевода и оценки качества
// 2. Обработки ошибок API
// 3. Взаимодействия с формой
//
// Фреймворк: Cypress
// Моки: cy.intercept() (для перехвата и подмены HTTP запросов)
// ===========================================================================================

describe('AI Translator & Critic - Основные сценарии', () => {
  /**
   * Что такое describe?
   * --------------------
   * describe - это функция, которая группирует несколько тестов в один набор.
   * Внутри describe можно быть несколько test() или it() блоков.
   * 
   * Синтаксис:
   * describe('Название тестовой группы', () => {
   *   // Здесь располагаются отдельные тесты
   *   it('тест 1', () => { ... })
   *   it('тест 2', () => { ... })
   * })
   */

  // ===========================================================================================
  // ХУКИ - beforeEach
  // ===========================================================================================

  beforeEach(() => {
    /**
     * Что такое beforeEach?
     * ----------------------
     * beforeEach - это хук, который выполняется ПЕРЕД КАЖДЫМ тестом.
     * Здесь мы обычно:
     * 1. Настраиваем моки
     * 2. Переходим на страницу
     * 3. Проверяем начальное состояние
     * 
     * Это удобно, потому что не нужно повторять одинаковый код в каждом тесте.
     */

    // Шаг 1: Переходим на главную страницу приложения
    // cy.visit('/') использует baseUrl из cypress.config.js
    // Итого: http://localhost:5000/
    cy.visit('/');

    /**
     * Шаг 2: Проверяем, что страница загрузилась корректно
     * cy.contains() ищет элемент, содержащий указанный текст
     */
    cy.contains('AI Translator & Critic').should('be.visible');
  });

  // ===========================================================================================
  // ТЕСТ 1: УСПЕШНЫЙ ПЕРЕВОД И ОЦЕНКА КАЧЕСТВА
  // ===========================================================================================

  it('Должен успешно выполнить перевод и оценку качества', () => {
    /**
     * ОПИСАНИЕ ТЕСТА:
     * ---------------
     * Этот тест проверяет полный цикл работы приложения:
     * 1. Ввод текста в форму
     * 2. Выбор языка
     * 3. Нажатие кнопки "Перевести"
     * 4. Получение результатов перевода
     * 5. Получение оценки качества
     * 
     * КЛЮЧЕВОЙ МОМЕНТ: Мы не делаем реальные запросы к API!
     * Вместо этого используем cy.intercept() для подмены ответов.
     */

    // ==========================================
    // SETUP: Настройка моков для API запросов
    // ==========================================

    /**
     * Что такое cy.intercept()?
     * --------------------------
     * cy.intercept() - это мощная функция Cypress, которая:
     * 1. Перехватывает HTTP запросы
     * 2. Позволяет нам подменить ответ (вместо реального запроса к API)
     * 3. Дает нам возможность проверить, был ли запрос отправлен
     * 
     * Синтаксис:
     * cy.intercept(
     *   'METHOD',           // HTTP метод (GET, POST, PUT и т.д.)
     *   'URL или pattern',  // URL или паттерн для поиска
     *   routeHandler        // Функция, которая обрабатывает перехваченный запрос
     * ).as('aliasName')     // Даем перехвату имя для использования в assertions
     */

    // MOCK 1: Перехватываем запрос для перевода
    // Это запрос к модели Qwen/Qwen3-VL-30B-A3B-Instruct
    cy.intercept('POST', 'https://api.mentorpiece.org/v1/process-ai-request', (req) => {
      /**
       * Как это работает?
       * ------------------
       * 1. Cypress перехватывает POST запрос к указанному URL
       * 2. Функция получает объект req со всей информацией о запросе
       * 3. Мы проверяем req.body.model_name, чтобы узнать какую модель просят
       * 4. В зависимости от модели мы отправляем разные мок-ответы
       */

      // Проверяем какую модель запросили
      if (req.body.model_name === 'Qwen/Qwen3-VL-30B-A3B-Instruct') {
        /**
         * Это запрос для перевода!
         * Отправляем мок-ответ с переводом
         */
        req.reply({
          statusCode: 200, // HTTP статус код
          body: {
            response: 'Mocked Translation: The sun is shining.' // Мок перевод
          }
        });
      } else if (req.body.model_name === 'claude-sonnet-4-5-20250929') {
        /**
         * Это запрос для оценки качества!
         * Отправляем мок-ответ с оценкой
         */
        req.reply({
          statusCode: 200,
          body: {
            response: 'Mocked Grade: 9/10. Fluent and accurate translation.' // Мок оценка
          }
        });
      }
    }).as('apiRequest'); // Даем это перехвату имя 'apiRequest'

    // ==========================================
    // ДЕЙСТВИЕ: Заполнение и отправка формы
    // ==========================================

    /**
     * Шаг 1: Вводим текст в textarea
     * --------------------------------
     * cy.get() - это команда для поиска элемента на странице
     * Синтаксис: cy.get('селектор')
     * 
     * Селектор может быть:
     * - CSS селектор: 'input[type="text"]'
     * - ID селектор: '#original_text'
     * - Класс селектор: '.form-control'
     * - Атрибут селектор: '[name="original_text"]'
     */

    // Находим textarea с id='original_text' и вводим текст
    cy.get('#original_text')
      .clear() // Очищаем поле (на случай, если там что-то было)
      .type('Солнце светит.'); // Вводим текст

    // Проверяем, что текст введен корректно
    cy.get('#original_text').should('have.value', 'Солнце светит.');

    /**
     * Шаг 2: Выбираем язык из dropdown
     * ---------------------------------
     */
    cy.get('#target_language')
      .select('Английский'); // Выбираем опцию с текстом "Английский"

    // Проверяем, что язык выбран
    cy.get('#target_language').should('have.value', 'Английский');

    /**
     * Шаг 3: Нажимаем кнопку "Перевести"
     * -----------------------------------
     * cy.contains() ищет элемент по тексту
     * click() нажимает на элемент
     */
    cy.contains('button', 'Перевести').click();

    // ==========================================
    // ПРОВЕРКА 1: Перевод был выполнен
    // ==========================================

    /**
     * Проверяем, что мок-ответ с переводом появился на странице
     * cy.contains() ищет элемент, содержащий указанный текст
     * should('be.visible') проверяет, что элемент виден
     */
    cy.contains('Mocked Translation: The sun is shining.')
      .should('be.visible');

    // ==========================================
    // ПРОВЕРКА 2: Проверяем, что запрос был отправлен
    // ==========================================

    /**
     * cy.wait() - это команда для ожидания
     * @aliasName - ждем перехвата с именем 'apiRequest'
     * 
     * Это очень полезно, потому что:
     * 1. Мы убедимся, что запрос действительно был отправлен
     * 2. Мы сможем проверить содержимое запроса (body, headers и т.д.)
     * 3. Если запрос не будет отправлен за отведенное время, тест упадет
     */
    cy.wait('@apiRequest').then((interception) => {
      /**
       * interception.request содержит информацию о отправленном запросе
       * Мы можем проверить:
       * - interception.request.body - тело запроса (JSON)
       * - interception.request.headers - заголовки
       * - interception.request.url - URL
       */

      // Проверяем, что это запрос на перевод (с моделью Qwen)
      expect(interception.request.body.model_name).to.include('Qwen');

      // Проверяем, что промпт содержит наш текст
      expect(interception.request.body.prompt).to.include('Солнце светит');

      // Проверяем, что Authorization header присутствует
      expect(interception.request.headers).to.have.property('Authorization');
    });

    // ==========================================
    // ПРОВЕРКА 3: Оценка качества
    // ==========================================

    /**
     * Проверяем, что мок-ответ с оценкой появился на странице
     */
    cy.contains('Mocked Grade: 9/10. Fluent and accurate translation.')
      .should('be.visible');

    /**
     * Проверяем, что второй запрос (на оценку) был отправлен
     * cy.wait() с count опцией для ожидания нескольких перехватов
     */
    cy.get('@apiRequest.all').then((requests) => {
      /**
       * requests.all содержит все перехваченные запросы
       * Проверяем, что их было минимум 2
       */
      expect(requests.length).to.be.at.least(1);
    });

    // ==========================================
    // ФИНАЛЬНАЯ ПРОВЕРКА: Весь контент виден
    // ==========================================

    // Проверяем исходный текст
    cy.contains('Солнце светит.').should('be.visible');

    // Проверяем перевод
    cy.contains('The sun is shining').should('be.visible');

    // Проверяем оценку
    cy.contains('9/10').should('be.visible');
  });

  // ===========================================================================================
  // ТЕСТ 2: ОБРАБОТКА ОШИБКИ API (500 Internal Server Error)
  // ===========================================================================================

  it('Должен обработать ошибку API 500 и показать сообщение об ошибке', () => {
    /**
     * ОПИСАНИЕ ТЕСТА:
     * ---------------
     * Этот тест проверяет, что приложение корректно обрабатывает ошибки от API.
     * Мы мокируем ситуацию, где API возвращает ошибку 500.
     */

    // ==========================================
    // SETUP: Настройка мока для ошибки API
    // ==========================================

    /**
     * Мокируем оба запроса (и для перевода, и для оценки) для возврата ошибки 500
     */
    cy.intercept('POST', 'https://api.mentorpiece.org/v1/process-ai-request', {
      /**
       * Эта форма cy.intercept() проще и более универсальна.
       * Мы не проверяем содержимое запроса, просто отправляем ошибку 500
       * для всех POST запросов к этому URL.
       */
      statusCode: 500, // Internal Server Error
      body: {
        error: 'Internal Server Error'
      }
    }).as('apiErrorRequest');

    // ==========================================
    // ДЕЙСТВИЕ: Заполнение и отправка формы
    // ==========================================

    // Вводим текст
    cy.get('#original_text')
      .clear()
      .type('Проверка обработки ошибок');

    // Выбираем язык
    cy.get('#target_language').select('Французский');

    // Нажимаем кнопку "Перевести"
    cy.contains('button', 'Перевести').click();

    // ==========================================
    // ПРОВЕРКА: Сообщение об ошибке
    // ==========================================

    /**
     * Проверяем, что на странице появилось сообщение об ошибке.
     * Сообщение может содержать:
     * - Текст "ошибка" или "error"
     * - Символ "❌"
     * - Текст про статус код "500"
     * 
     * Мы используем cy.contains() с регулярным выражением для поиска по разным вариантам.
     */

    // Проверяем наличие сообщения об ошибке
    cy.get('body').then(($body) => {
      /**
       * Проверяем различные варианты сообщений об ошибке
       */
      const hasError = (
        $body.text().includes('ошибка') ||
        $body.text().includes('error') ||
        $body.text().includes('❌') ||
        $body.text().includes('500') ||
        $body.text().includes('API')
      );

      expect(hasError).to.be.true;
    });

    /**
     * Дополнительная проверка: API запрос все еще был отправлен
     * (даже если он вернул ошибку)
     */
    cy.wait('@apiErrorRequest');
  });

  // ===========================================================================================
  // ТЕСТ 3: ПРОВЕРКА КОРРЕКТНОГО ЗАПОЛНЕНИЯ ФОРМЫ
  // ===========================================================================================

  it('Должен сохранять значения в форме после отправки', () => {
    /**
     * ОПИСАНИЕ ТЕСТА:
     * ---------------
     * Этот тест проверяет, что значения в форме сохраняются после отправки.
     * Это важно для UX - пользователь может видеть что он вводил.
     */

    // Мокируем API запросы
    cy.intercept('POST', 'https://api.mentorpiece.org/v1/process-ai-request', (req) => {
      if (req.body.model_name === 'Qwen/Qwen3-VL-30B-A3B-Instruct') {
        req.reply({
          statusCode: 200,
          body: {
            response: 'Mocked: Test translation result'
          }
        });
      } else if (req.body.model_name === 'claude-sonnet-4-5-20250929') {
        req.reply({
          statusCode: 200,
          body: {
            response: 'Mocked: 8/10'
          }
        });
      }
    });

    const testText = 'Тестовый текст для проверки';
    const testLanguage = 'Немецкий';

    // Вводим текст
    cy.get('#original_text').type(testText);

    // Выбираем язык
    cy.get('#target_language').select(testLanguage);

    // Нажимаем "Перевести"
    cy.contains('button', 'Перевести').click();

    // ==========================================
    // ПРОВЕРКА: Значения остались в форме
    // ==========================================

    // Проверяем, что текст остался в textarea
    cy.get('#original_text').should('have.value', testText);

    // Проверяем, что язык остался выбранным
    cy.get('#target_language').should('have.value', testLanguage);
  });

  // ===========================================================================================
  // ТЕСТ 4: ПРОВЕРКА ВАЛИДАЦИИ ПУСТОГО ПОЛЯ
  // ===========================================================================================

  it('Должен показать ошибку при попытке отправить пустое поле', () => {
    /**
     * ОПИСАНИЕ ТЕСТА:
     * ---------------
     * Этот тест проверяет фронтенд валидацию - что приложение не даст
     * отправить форму с пустым текстом.
     */

    // Пытаемся нажать кнопку без ввода текста
    // (поле уже пусто после cy.visit)

    // Нажимаем кнопку "Перевести"
    cy.contains('button', 'Перевести').click();

    /**
     * Когда HTML5 валидация срабатывает, браузер показывает встроенное
     * сообщение об ошибке. Cypress может перехватить такие ошибки.
     * 
     * Однако в нашем случае есть также JavaScript валидация,
     * которая показывает alert().
     * 
     * Мы можем проверить, что alert был вызван, используя cy.on()
     */

    // Проверяем, что alert был показан пользователю
    cy.on('window:alert', (alertText) => {
      /**
       * Cypress позволяет перехватить alert сообщения
       * Мы проверяем содержимое alert текста
       */
      expect(alertText).to.include('текст');
    });
  });

  // ===========================================================================================
  // ТЕСТ 5: ПРОВЕРКА АСИНХРОННОЙ ОБРАБОТКИ
  // ===========================================================================================

  it('Должен корректно обрабатывать асинхронные запросы', () => {
    /**
     * ОПИСАНИЕ ТЕСТА:
     * ---------------
     * Этот тест проверяет, что Cypress правильно ждет ответа от API
     * и не проверяет результаты до их появления на странице.
     */

    // Мокируем медленный API (имитируем задержку 2 секунды)
    cy.intercept('POST', 'https://api.mentorpiece.org/v1/process-ai-request', (req) => {
      /**
       * cy.intercept() с функцией позволяет нам добавить задержку
       * и эмулировать медленный API
       */

      // Имитируем задержку сети (2 секунды)
      req.reply((res) => {
        // res.delay(2000); // Можно раскомментировать для эмуляции задержки

        if (req.body.model_name === 'Qwen/Qwen3-VL-30B-A3B-Instruct') {
          res.send({
            statusCode: 200,
            body: {
              response: 'Translation after delay'
            }
          });
        } else if (req.body.model_name === 'claude-sonnet-4-5-20250929') {
          res.send({
            statusCode: 200,
            body: {
              response: 'Grade after delay: 7/10'
            }
          });
        }
      });
    }).as('delayedRequest');

    // Заполняем форму
    cy.get('#original_text').type('Текст для задержанного перевода');
    cy.get('#target_language').select('Английский');

    // Нажимаем кнопку
    cy.contains('button', 'Перевести').click();

    /**
     * Cypress автоматически ждет перехваченного запроса
     * благодаря управлению командным очередью.
     * 
     * Когда мы используем cy.contains() или другие команды,
     * Cypress ждет, пока результаты появятся на странице
     * (или выбросит ошибку если они не появятся в отведенное время).
     */

    // Проверяем результаты (Cypress автоматически подождет их появления)
    cy.contains('Translation after delay').should('be.visible');
    cy.contains('Grade after delay').should('be.visible');
  });
});

// ===========================================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ И КОММЕНТАРИИ К CYPRESS API
// ===========================================================================================

/**
 * ОСНОВНЫЕ КОМАНДЫ CYPRESS
 * =======================
 *
 * 1. cy.visit(url)
 *    - Переходит по URL
 *    - Пример: cy.visit('/')
 *
 * 2. cy.get(selector)
 *    - Находит элемент по CSS селектору
 *    - Пример: cy.get('#myButton')
 *
 * 3. cy.contains(text) или cy.contains(selector, text)
 *    - Находит элемент по содержимому текста
 *    - Пример: cy.contains('Нажми меня')
 *
 * 4. .type(text)
 *    - Вводит текст в фокусированное поле
 *    - Пример: cy.get('input').type('Hello')
 *
 * 5. .click()
 *    - Нажимает на элемент
 *    - Пример: cy.get('button').click()
 *
 * 6. .select(value)
 *    - Выбирает опцию из dropdown
 *    - Пример: cy.get('select').select('Option 1')
 *
 * 7. .should(assertion)
 *    - Проверяет условие
 *    - Примеры:
 *      .should('be.visible') - элемент виден
 *      .should('have.value', 'text') - поле содержит текст
 *      .should('contain', 'text') - текст содержит
 *
 * 8. cy.intercept()
 *    - Перехватывает и мокирует HTTP запросы
 *    - Пример: cy.intercept('GET', '/api/users', [])
 *
 * 9. cy.wait(@alias)
 *    - Ждет перехваченного запроса
 *    - Пример: cy.wait('@getUsers')
 *
 * 10. .as(alias)
 *     - Дает имя элементу для последующего использования
 *     - Пример: cy.get('form').as('myForm')
 */

/**
 * ЛУЧШИЕ ПРАКТИКИ ДЛЯ НАПИСАНИЯ CYPRESS ТЕСТОВ
 * =============================================
 *
 * 1. Используйте моки для внешних API
 *    - Не делайте реальные запросы к API
 *    - Это медленно и ненадежно
 *    - Используйте cy.intercept()
 *
 * 2. Ждите асинхронных элементов
 *    - Не используйте жесткие sleep() команды
 *    - Cypress автоматически ждет элементы
 *    - Используйте should() для проверки состояния
 *
 * 3. Тестируйте пользовательский опыт
 *    - Пишите тесты так, как пользователь взаимодействует с приложением
 *    - Вводит текст -> выбирает опцию -> нажимает кнопку
 *    - Не тестируйте внутренние реализационные детали
 *
 * 4. Используйте описательные имена тестов
 *    - Название теста должно описывать что он проверяет
 *    - "Должен успешно выполнить перевод" (ХОРОШО)
 *    - "test_1" (ПЛОХО)
 *
 * 5. Используйте beforeEach для повторяющегося кода
 *    - Не повторяйте код в каждом тесте
 *    - Поместите его в beforeEach()
 */
